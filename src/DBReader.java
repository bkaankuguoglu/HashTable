import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

public class DBReader {
	private static HashTable hashtable = new HashTable();
	private static String text;
	private static String sortedText;

/* It reads the txt file input.txt and writes each key-value into the txt file output.txt line by line as
 * it adds a new pair to the hashmap.
 * 	
 */
public static HashTable readDatabase() {
		text = "";
		BufferedReader bufferedReader = null;
		BufferedWriter bufferedWriter = null;
		try {

			String sCurrentLine;

			bufferedReader = new BufferedReader(new FileReader("input.txt"));
			bufferedWriter = new BufferedWriter(new FileWriter("output.txt"));

			while ((sCurrentLine = bufferedReader.readLine()) != null) {
				System.out.println(sCurrentLine);
			    String [] tokens = sCurrentLine.split("\\s+");
			    String key = tokens[0];
			    String value = "";
			    String [] keyValuePair = new String[2];
			    for (int i = 1; i < tokens.length; i++) {
					value += tokens[i] + " ";
				}
			    
			    /* The case for put keyword.
			     */
			    if(key.equalsIgnoreCase("put")){
			    	key = tokens[1];
			    	value = "";
			    	for (int i = 2; i < tokens.length; i++) {
						value += tokens[i] + " ";
					} 
			    	System.out.println("The key (" + key + "," + value + ") is put in the hashmap.");
			    }
			    
			    /* The case for size keyword
			     */
			    else if(key.equalsIgnoreCase("size")){
			    	System.out.println("The number of elements in the hashmap = " + hashtable.size());
			    	bufferedWriter.write("\nThe size of the table is: " + hashtable.size() + "\n");
			    	text += "\nThe size of the table is: " + hashtable.size() + "\n";
			    	continue;
			    }
			    /* The case for containsKey keyword
			     */
			    else if(key.equalsIgnoreCase("containsKey")){
			    	key = tokens[1];
			    	System.out.println(hashtable.containsKey(key));
			    	bufferedWriter.write("\n" + hashtable.containsKey(key).toString() + "\n");
			    	text += "\n" + hashtable.containsKey(key).toString() + "\n";
			    	continue;
			    }
			    
			    /* The case for empty line to prevent it from adding ("","") to the hashmap.
			     */
			    else if(key.equalsIgnoreCase("")){
			    	bufferedWriter.write("\n" + text );
			    	continue;
			    }
			    

	   
			    keyValuePair[0] = key;
			    keyValuePair[1] = value;			    
			    hashtable.put(key, value);
			    int hash = HashTable.hash(key);
		    	bufferedWriter.write(hash + ":" + key + " " + value + "\n");
		    	text += hash + ":" + key + " " + value + "\n";
			}
			
			System.out.println("\nThe input text is read successfully. \n");
			sortedText = sortHashTable();
			//System.out.println(sortedText);

			return hashtable;

			
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (bufferedReader != null)
					bufferedReader.close();
					bufferedWriter.close();
			} catch (IOException ex) {
				ex.printStackTrace();
			}
		}
		return hashtable;
		
	}

/* Sorts the hash table and returns a String value what contains each key value pair line by line in
 * an ascending order.
 */

public static String sortHashTable() {
	sortedText = "";
	Node node;
	Node trailer;
	for (int i = 0; i < hashtable.capacity(); i++) {
		if(hashtable.getHashTable()[i]!=null){
			node = hashtable.getHashTable()[i].getHeader().getNext();
			trailer = hashtable.getHashTable()[i].getTrailer();
			while(node!=trailer){
				sortedText += i + ":" + node.getKey() + " " + node.getValue() + "\n";
				node = node.getNext();
			}
		}		
	}
	return sortedText;
}
/* Takes the sorted text generated by sortHashTable() and writes it to the output2.txt
 * Actually there was no need to implement a class like this, however the sample output file
 * is in order corresponding to the keys of elements. Since all of these key-value pairs
 * are not in order, writing them to the output.txt one by one is not also in order. 
 * So if there is any need, here is the method that writes the current hashtable whenever it's needed.
 * 
 */
public static void writeSortedHashTable(){
	sortedText = sortHashTable();
	BufferedWriter bufferedWriter = null;
	try {
		bufferedWriter = new BufferedWriter(new FileWriter("output2.txt"));
	    bufferedWriter.write(sortedText);
		
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		try {
			if (bufferedWriter != null)
				bufferedWriter.close();
		} catch (IOException ex) {
			ex.printStackTrace();
		}
	}
	
}
	

}


	

